---
status: complete
priority: p2
issue_id: "012"
tags: [code-review, performance, reliability, frontend]
dependencies: []
---

# Prevent Session Storage Cache Key Leak

Ensure coverage collection cache writes clean up previous language cache payload keys.

## Problem Statement

Cache writes create a new timestamped `sessionStorage` data key each time, but old data keys are not removed before metadata is overwritten. Repeated usage can accumulate orphaned cache entries and eventually hit storage quota.

## Findings

- `src/features/coverage/coverage-report-client.tsx:174` writes to a new `dataKey` for each cache write.
- `src/features/coverage/coverage-report-client.tsx:189` overwrites metadata with latest key without deleting prior key.
- `clearCachedCollections` only removes the key currently pointed to by metadata; older orphaned keys remain inaccessible and uncollected.

## Proposed Solutions

### Option 1: Delete prior `dataKey` before writing new cache metadata

**Approach:** In `writeCachedCollections`, read previous metadata and remove previous `dataKey` when it differs from the new key.

**Pros:**
- Minimal code change
- Prevents unbounded per-language key growth

**Cons:**
- Requires careful try/catch to avoid write failures if old metadata is malformed

**Effort:** 30-60 minutes

**Risk:** Low

---

### Option 2: Use stable per-language data key

**Approach:** Replace timestamped `dataKey` with deterministic key (`ai-media-collections-${languageId}-data`) and keep metadata separate.

**Pros:**
- No key churn
- Simpler lifecycle management

**Cons:**
- Slightly larger refactor than cleanup-on-write

**Effort:** 1-2 hours

**Risk:** Medium

## Recommended Action

Completed with **Option 1**:
- `writeCachedCollections` now removes the previous `dataKey` before writing a new entry,
- metadata format remains compatible,
- focused cache lifecycle tests were added.

## Technical Details

**Affected files:**
- `/videoforge/src/features/coverage/coverage-report-client.tsx:174`
- `/videoforge/src/features/coverage/coverage-report-client.tsx:200`

**Related components:**
- Coverage client session cache
- Collection refresh behavior

**Database changes (if any):**
- No

## Resources

- **Branch:** `prev-version-merge-code-1`
- **Related UI module:** `/videoforge/src/features/coverage/coverage-report-client.tsx`

## Acceptance Criteria

- [x] Cache writes do not leave orphaned `sessionStorage` data keys
- [x] Repeated refreshes/language switches keep storage footprint bounded
- [x] Add focused tests for cache key lifecycle (write/update/clear)
- [x] Existing coverage page tests pass

## Work Log

### 2026-02-15 - Initial Discovery

**By:** Codex

**Actions:**
- Inspected cache read/write/clear flow in coverage client
- Traced key lifecycle across refresh and language changes
- Identified orphan key accumulation path
- Selected Option 1 for implementation (delete previous `dataKey` on write)

**Learnings:**
- Metadata cleanup currently only handles the latest key, not historical keys generated by timestamped writes.

### 2026-02-16 - Implemented and Verified

**By:** Codex

**Actions:**
- Added `/videoforge/src/features/coverage/collection-cache.ts` and moved cache lifecycle logic into testable helpers.
- Updated `/videoforge/src/features/coverage/coverage-report-client.tsx` to use shared cache helpers.
- Added `/videoforge/tests/coverage-collection-cache.test.ts` to validate replacement cleanup, expiry eviction, and explicit clear behavior.

**Learnings:**
- Isolating cache lifecycle logic into a utility module reduced component complexity and made leak prevention easy to verify.

## Notes

- This is a client-side reliability/performance issue that can degrade over longer sessions.
